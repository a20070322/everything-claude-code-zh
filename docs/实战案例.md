# 实战案例 - Everything Claude Code 真实应用场景

**目标：** 通过真实案例学习如何在实际项目中使用 Everything Claude Code

---

## 目录

- [案例 1：快速开发新功能](#案例-1快速开发新功能)
- [案例 2：修复复杂 Bug](#案例-2修复复杂-bug)
- [案例 3：代码重构](#案例-3代码重构)
- [案例 4：安全审查](#案例-4安全审查)
- [案例 5：持续学习](#案例-5持续学习)

---

## 案例 1：快速开发新功能

### 场景描述

**任务：** 为电商网站添加购物车功能

**要求：**
- 商品添加到购物车
- 购物车数量管理
- 价格计算
- 本地持久化

### 使用流程

#### 步骤 1：规划功能

```bash
我需要开发一个购物车功能，包含添加商品、数量管理、价格计算

使用 /plan 命令帮我规划这个功能
```

**Claude 的响应：**

1. 调用 `planner` 子代理
2. 分析需求
3. 创建实施计划：

```
# 实施计划：购物车功能

## 功能概述
实现完整的购物车功能，支持商品管理、数量调整和价格计算

## 技术方案
- 状态管理：Pinia + localStorage 持久化
- 类型安全：TypeScript 接口定义
- 组件设计：Cart 组件、CartItem 组件

## 实施步骤

### Phase 1: 类型定义
1. 定义 CartItem 接口
2. 定义 CartState 接口
3. 定义购物车操作类型

### Phase 2: Store 实现
1. 创建 Pinia store
2. 实现 actions
3. 实现 getters
4. 实现持久化

### Phase 3: 组件开发
1. CartItem 组件
2. Cart 组件
3. CartIcon 组件

### Phase 4: 集成
1. 集成到产品页面
2. 添加购物车图标
3. 实现路由
```

#### 步骤 2：TDD 开发

```
使用 /tdd 进入 TDD 模式开始实现
```

**Claude 的响应：**

1. 激活 `tdd-workflow` 技能
2. 先写测试：

```typescript
// cart.spec.ts
describe('CartStore', () => {
  it('should add item to cart', () => {
    const store = useCartStore()
    const item: CartItem = { id: 1, name: 'Product', price: 100 }

    store.addItem(item)

    expect(store.items).toContain(item)
    expect(store.totalPrice).toBe(100)
  })

  it('should remove item from cart', () => {
    // ...
  })

  it('should update quantity', () => {
    // ...
  })
})
```

3. 运行测试（失败）
4. 实现代码
5. 运行测试（通过）
6. 重构代码

#### 步骤 3：代码审查

```
实现完成后，使用 /code-review 审查代码质量
```

**Claude 的响应：**

1. 调用 `code-reviewer` 子代理
2. 检查代码规范
3. 提供改进建议：

```markdown
## 代码审查结果

### ✅ 优点
- 类型定义完整
- 测试覆盖充分（100%）
- 代码结构清晰

### ⚠️ 需要改进
1. **性能优化**
   - 价格计算可以使用 memo 优化
   - 考虑使用 computed 缓存总价

2. **错误处理**
   - 添加数量验证（不能为负数）
   - 添加库存检查

3. **代码规范**
   - 接口定义移到 types/ 目录
   - 使用常量定义购物车操作类型
```

#### 步骤 4：验证

```
改进完成后，使用 /verify 验证所有更改
```

**验证结果：**
- ✅ 类型检查通过
- ✅ 代码规范检查通过
- ✅ 所有测试通过
- ✅ 构建成功

### 最终结果

```
功能开发时间：2 小时（传统方式需要 4 小时）
代码质量：⭐⭐⭐⭐⭐
测试覆盖率：100%
返工次数：1 次
```

---

## 案例 2：修复复杂 Bug

### 场景描述

**Bug 报告：**
```
TypeError: Cannot read property 'user' of undefined
  at UserService.getUserInfo (user.service.ts:45)
```

**问题：**
- 只在生产环境出现
- 无法重现
- 影响用户登录

### 使用流程

#### 步骤 1：诊断问题

```
我遇到了一个生产环境的 Bug：
TypeError: Cannot read property 'user' of undefined

请帮我诊断问题
```

**Claude 的响应：**

1. 分析错误堆栈
2. 检查 `user.service.ts:45`
3. 识别潜在原因：

```markdown
## 问题诊断

### 可能原因
1. API 响应格式不正确
2. 未处理空响应
3. 数据解析错误

### 建议检查
1. API 返回的数据结构
2. 错误处理逻辑
3. 边界条件（空数据）
```

#### 步骤 2：查看代码

```
查看 src/services/user.service.ts 第 45 行附近的代码
```

**Claude 的响应：**

```typescript
// 第 45 行
const userInfo = this.apiResponse.data.user
//        ^^^^^^^^^^^^^^^^^^^^^^^^^^
//        这里可能 undefined
```

**问题：**
- `apiResponse.data` 可能为 undefined
- 没有错误处理

#### 步骤 3：修复代码

**修复方案：**

```typescript
// 修复前
const userInfo = this.apiResponse.data.user

// 修复后
const userInfo = this.apiResponse?.data?.user

if (!userInfo) {
  throw new Error('User information not available')
}
```

#### 步骤 4：添加测试

```
为这个修复添加测试用例，确保不会再次出现
```

**Claude 的响应：**

```typescript
describe('UserService', () => {
  it('should handle empty API response', () => {
    // 模拟空响应
    mockApi.getuserInfo.mockReturnValue({ data: null })

    expect(() => service.getUserInfo()).toThrow('User information not available')
  })

  it('should handle malformed response', () => {
    // 模拟格式错误的响应
    mockApi.getuserInfo.mockReturnValue({ data: {} })

    expect(() => service.getUserInfo()).toThrow()
  })
})
```

#### 步骤 5：验证

```
使用 /verify 验证修复
```

**验证结果：**
- ✅ 修复了原始 Bug
- ✅ 添加了边界条件处理
- ✅ 测试覆盖新增场景
- ✅ 代码审查通过

### 最终结果

```
Bug 修复时间：30 分钟
新增测试：3 个
回归测试：已添加
```

---

## 案例 3：代码重构

### 场景描述

**问题：**
```
UserDashboard.tsx 文件太大（1200 行）
- 包含太多逻辑
- 难以维护
- 测试困难
```

### 使用流程

#### 步骤 1：分析代码

```
UserDashboard.tsx 文件有 1200 行，包含了太多逻辑

使用 /refactor-clean 帮我重构这个文件
```

**Claude 的响应：**

1. 调用 `refactor-cleaner` 子代理
2. 分析文件结构
3. 识别重构机会：

```markdown
## 重构分析

### 文件结构
- 当前：1200 行，单个文件
- 包含：用户信息、订单列表、设置、统计分析

### 重构建议
1. **拆分组件**
   - UserInfo 组件（200 行）
   - OrderList 组件（300 行）
   - UserSettings 组件（250 行）
   - StatsCharts 组件（250 行）
   - 主仪表板（200 行）

2. **提取自定义 Hooks**
   - useUserData.ts
   - useOrders.ts
   - useStats.ts

3. **提取类型定义**
   - types/user.ts
   - types/order.ts

4. **删除死代码**
   - 未使用的导入：15 个
   - 重复的函数：3 个
   - 注释掉的代码：200 行
```

#### 步骤 2：执行重构

**Claude 执行重构：**

1. 创建新的组件文件
2. 提取自定义 Hooks
3. 重构主组件
4. 更新导入

**重构后结构：**

```
UserDashboard.tsx (200 行)         ↓ 83%
├── components/
│   ├── UserInfo.tsx (200 行)
│   ├── OrderList.tsx (300 行)
│   ├── UserSettings.tsx (250 行)
│   └── StatsCharts.tsx (250 行)
├── hooks/
│   ├── useUserData.ts (50 行)
│   ├── useOrders.ts (80 行)
│   └── useStats.ts (100 行)
└── types/
    ├── user.ts (30 行)
    └── order.ts (40 行)
```

#### 步骤 3：自动格式化和检查

**Hooks 自动执行：**
- ✅ Prettier 自动格式化所有文件
- ✅ TypeScript 类型检查
- ✅ ESLint 检查代码规范

#### 步骤 4：验证

```
重构完成，使用 /verify 验证
```

**验证结果：**
- ✅ 功能完全保持
- ✅ 所有测试通过
- ✅ 代码质量提升
- ✅ 可维护性大幅改善

### 最终结果

```
重构时间：1.5 小时
代码行数：1200 → 200 行（主文件）
总代码行数：保持
组件数量：1 → 5
可维护性：⭐ → ⭐⭐⭐⭐
测试覆盖率：80% → 95%
```

---

## 案例 4：安全审查

### 场景描述

**任务：** 对支付功能进行安全审查

**代码：** `src/payment/PaymentService.ts`

### 使用流程

#### 步骤 1：安全审查

```
审查 src/payment/PaymentService.ts 的安全性

使用 /security-review 进行安全审查
```

**Claude 的响应：**

1. 激活 `security-review` 技能
2. 调用 `security-reviewer` 子代理
3. 执行全面安全检查

**安全审查报告：**

```markdown
## 安全审查报告

### 🚨 严重问题

1. **API 密钥硬编码**
   ```typescript
   // ❌ 发现位置：第 15 行
   const STRIPE_SECRET_KEY = 'sk_test_...'
   ```
   **风险：** 密钥泄露会导致资金损失
   **修复：** 使用环境变量

2. **未验证支付金额**
   ```typescript
   // ❌ 发现位置：第 45 行
   const amount = request.amount
   ```
   **风险：** 用户可以修改金额
   **修复：** 后端验证金额

### ⚠️ 高危问题

3. **缺少 CSRF 保护**
   **风险：** 跨站请求伪造攻击
   **修复：** 添加 CSRF token

4. **未验证支付状态**
   **风险：** 支付状态可以被伪造
   **修复：** 验证 webhook 签名

### 💡 建议改进

5. **日志记录不足**
   - 添加支付操作日志
   - 记录失败原因

6. **错误处理不当**
   - 不暴露敏感信息
   - 提供用户友好的错误消息
```

#### 步骤 2：修复安全问题

**Claude 提供修复代码：**

```typescript
// 修复 1：使用环境变量
const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY

// 修复 2：验证金额
const validatedAmount = Math.min(request.amount, MAX_AMOUNT)

// 修复 3：CSRF 保护
import { validateCSRFToken } from './security.utils'
if (!validateCSRFToken(request.token)) {
  throw new Error('Invalid CSRF token')
}

// 修复 4：验证 webhook 签名
import { verifyWebhookSignature } from './stripe.utils'
if (!verifyWebhookSignature(payload, signature)) {
  throw new Error('Invalid webhook signature')
}
```

#### 步骤 3：添加测试

```
为安全修复添加测试
```

**测试代码：**

```typescript
describe('PaymentService Security', () => {
  it('should reject requests with invalid amount', () => {
    const result = service.processPayment({ amount: -100 })
    expect(result.success).toBe(false)
  })

  it('should validate webhook signature', () => {
    // 测试签名验证
  })

  it('should not expose secret keys in errors', () => {
    // 测试错误消息不包含密钥
  })
})
```

#### 步骤 4：验证

```
安全修复完成，使用 /verify 验证
```

**验证结果：**
- ✅ 所有严重问题已修复
- ✅ 测试覆盖新增
- ✅ 代码审查通过

### 最终结果

```
安全审查时间：1 小时
发现严重问题：2 个
发现问题：2 个
建议改进：2 个
修复时间：30 分钟
```

---

## 案例 5：持续学习

### 场景描述

**情况：**
- 团队解决了多个复杂问题
- 解决方案分散在各个成员的经验中
- 没有形成团队知识库

### 使用流程

#### 步骤 1：提取模式（多次）

**案例 A：解决状态管理问题**

```
我刚才解决了 Redux 状态管理的性能问题

使用 /learn 让 Claude 学习这个解决方案
```

**Claude 的响应：**

1. 分析会话内容
2. 识别问题-解决方案模式
3. 创建技能文件：

```markdown
# Redux 性能优化

**提取时间：** 2025-01-30
**上下文：** Redux 状态管理性能优化

## 问题
Redux store 更新导致频繁的组件重渲染，影响性能

## 解决方案
使用 reselect 创建记忆化的选择器：
- 避免不必要的重新计算
- 减少组件重渲染

## 示例代码
\`\`\`typescript
import { createSelector } from 'reselect'

export const selectUserName = createSelector(
  [(state: RootState) => state.user],
  (user) => user.name
)
\`\`\`

## 何时使用
- 当组件频繁重渲染时
- 当计算开销大时
- 当多个组件需要相同数据时
```

---

**案例 B：解决 TypeScript 类型错误**

```
我刚才解决了一个复杂的 TypeScript 类型推断问题

使用 /learn
```

**创建技能：**

```markdown
# TypeScript 类型推断技巧

**提取时间：** 2025-01-30

## 问题
TypeScript 无法正确推断联合类型

## 解决方案
使用类型守卫（type guards）：
- 缩小类型范围
- 明确类型判断

## 示例代码
\`\`\`typescript
function isString(value: unknown): value is string {
  return typeof value === 'string'
}
\`\`\`
```

---

#### 步骤 2：积累技能库

**一段时间后，技能库增长：**

```
~/.claude/skills/learned/
├── redux-performance-optimization.md
├── typescript-type-inference.md
├── react-hook-best-practices.md
├── api-error-handling.md
├── docker-development-tips.md
└── git-workflow-optimization.md
```

#### 步骤 3：团队共享

**将技能分享给团队：**

```bash
# 1. 将 learned/ 目录移到项目
mv ~/.claude/skills/learned/* project/.claude/skills/

# 2. 提交到 Git
git add .claude/skills/
git commit -m "docs: add team skills"

# 3. 团队成员拉取
git pull
```

**效果：**
- ✅ 团队知识得到沉淀
- ✅ 新成员快速上手
- ✅ 避免重复犯错
- ✅ 持续改进

---

## 总结

### 核心价值

Everything Claude Code 的价值在于：

1. **提高效率**
   - 自动化重复性工作
   - 快速执行复杂任务
   - 减少错误和返工

2. **保证质量**
   - 代码审查自动化
   - 安全检查自动化
   - 测试驱动开发

3. **持续改进**
   - 从经验中学习
   - 沉淀团队知识
   - 形成最佳实践

4. **团队协作**
   - 统一工作流程
   - 共享配置和技能
   - 标准化代码质量

### 使用技巧

1. **组合使用**
   - 命令可以组合：`/plan && /tdd`
   - 子代理可以链式调用
   - Hooks 自动化整个流程

2. **定制配置**
   - 根据项目调整技能
   - 根据团队定制规则
   - 根据流程配置 Hooks

3. **持续学习**
   - 定期使用 `/learn`
   - 更新技能库
   - 分享最佳实践

---

## 下一步

1. **开始使用**
   - [快速开始](./快速开始.md)
   - 选择一个案例尝试

2. **深入学习**
   - [组件详解](./组件详解.md)
   - [长篇指南](./translated/the-longform-guide.md)

3. **定制配置**
   - [定制指南](./定制指南.md)

---

**最后更新：** 2025-01-30
**难度级别：** ⭐⭐⭐ (高级)
**下一篇：** [定制指南](./定制指南.md)
